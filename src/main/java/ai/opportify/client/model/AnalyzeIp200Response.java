/*
 * Opportify Insights API
 * ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, corporate or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://www.opportify.ai).
 * https://www.opportify.ai
 * Do not edit the class manually.
 */


package ai.opportify.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import ai.opportify.client.model.BlockListed;
import ai.opportify.client.model.Geo;
import ai.opportify.client.model.RiskReport;
import ai.opportify.client.model.TrustedProvider;
import ai.opportify.client.model.Whois;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ai.opportify.client.JSON;

/**
 * AnalyzeIp200Response
 */
@javax.annotation.Generated(value = "ai.opportify.codegen.languages.JavaClientCodegen", date = "2025-01-07T17:36:50.096636-08:00[America/Los_Angeles]", comments = "Generator version: 7.10.0")
public class AnalyzeIp200Response {
  public static final String SERIALIZED_NAME_IP_ADDRESS = "ipAddress";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS)
  @javax.annotation.Nonnull
  private String ipAddress;

  public static final String SERIALIZED_NAME_IP_ADDRESS_NUMBER = "ipAddressNumber";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS_NUMBER)
  @javax.annotation.Nonnull
  private Integer ipAddressNumber;

  public static final String SERIALIZED_NAME_IP_TYPE = "ipType";
  @SerializedName(SERIALIZED_NAME_IP_TYPE)
  @javax.annotation.Nonnull
  private String ipType;

  public static final String SERIALIZED_NAME_IP_CIDR = "ipCidr";
  @SerializedName(SERIALIZED_NAME_IP_CIDR)
  @javax.annotation.Nonnull
  private String ipCidr;

  public static final String SERIALIZED_NAME_CONNECTION_TYPE = "connectionType";
  @SerializedName(SERIALIZED_NAME_CONNECTION_TYPE)
  @javax.annotation.Nonnull
  private String connectionType;

  public static final String SERIALIZED_NAME_HOST_REVERSE = "hostReverse";
  @SerializedName(SERIALIZED_NAME_HOST_REVERSE)
  @javax.annotation.Nonnull
  private String hostReverse;

  public static final String SERIALIZED_NAME_GEO = "geo";
  @SerializedName(SERIALIZED_NAME_GEO)
  @javax.annotation.Nonnull
  private Geo geo;

  public static final String SERIALIZED_NAME_WHOIS = "whois";
  @SerializedName(SERIALIZED_NAME_WHOIS)
  @javax.annotation.Nonnull
  private Whois whois;

  public static final String SERIALIZED_NAME_TRUSTED_PROVIDER = "trustedProvider";
  @SerializedName(SERIALIZED_NAME_TRUSTED_PROVIDER)
  @javax.annotation.Nonnull
  private TrustedProvider trustedProvider;

  public static final String SERIALIZED_NAME_BLOCKLISTED = "blocklisted";
  @SerializedName(SERIALIZED_NAME_BLOCKLISTED)
  @javax.annotation.Nonnull
  private BlockListed blocklisted;

  public static final String SERIALIZED_NAME_RISK_REPORT = "riskReport";
  @SerializedName(SERIALIZED_NAME_RISK_REPORT)
  @javax.annotation.Nonnull
  private RiskReport riskReport;

  public AnalyzeIp200Response() {
  }

  public AnalyzeIp200Response ipAddress(@javax.annotation.Nonnull String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

  /**
   * The analyzed IP address.
   * @return ipAddress
   */
  @javax.annotation.Nonnull
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(@javax.annotation.Nonnull String ipAddress) {
    this.ipAddress = ipAddress;
  }


  public AnalyzeIp200Response ipAddressNumber(@javax.annotation.Nonnull Integer ipAddressNumber) {
    this.ipAddressNumber = ipAddressNumber;
    return this;
  }

  /**
   * Numeric representation of the IP address.
   * @return ipAddressNumber
   */
  @javax.annotation.Nonnull
  public Integer getIpAddressNumber() {
    return ipAddressNumber;
  }

  public void setIpAddressNumber(@javax.annotation.Nonnull Integer ipAddressNumber) {
    this.ipAddressNumber = ipAddressNumber;
  }


  public AnalyzeIp200Response ipType(@javax.annotation.Nonnull String ipType) {
    this.ipType = ipType;
    return this;
  }

  /**
   * Type of the IP address (IPv4 or IPv6).
   * @return ipType
   */
  @javax.annotation.Nonnull
  public String getIpType() {
    return ipType;
  }

  public void setIpType(@javax.annotation.Nonnull String ipType) {
    this.ipType = ipType;
  }


  public AnalyzeIp200Response ipCidr(@javax.annotation.Nonnull String ipCidr) {
    this.ipCidr = ipCidr;
    return this;
  }

  /**
   * CIDR notation of the IP address.
   * @return ipCidr
   */
  @javax.annotation.Nonnull
  public String getIpCidr() {
    return ipCidr;
  }

  public void setIpCidr(@javax.annotation.Nonnull String ipCidr) {
    this.ipCidr = ipCidr;
  }


  public AnalyzeIp200Response connectionType(@javax.annotation.Nonnull String connectionType) {
    this.connectionType = connectionType;
    return this;
  }

  /**
   * The **connectionType** element provides information about the type of connection associated with a given IP address. Our system employs a **dynamic and evolving approach**, leveraging multiple data points to identify the connection type as accurately as possible.  - **wired**: A traditional wired connection (e.g., DSL, fiber, cable). - **mobile**: A mobile network connection (e.g., 4G, 5G). - **enterprise**: A connection from a known large business or corporate network. - **satellite**: A satellite internet connection. - **vpn**: A connection routed through a Virtual Private Network. - **cloud-provider**: A connection from a cloud hosting provider (e.g., AWS, Azure). - **open-proxy**: A connection using an open or public proxy. - **tor**: A connection routed through the Tor network. 
   * @return connectionType
   */
  @javax.annotation.Nonnull
  public String getConnectionType() {
    return connectionType;
  }

  public void setConnectionType(@javax.annotation.Nonnull String connectionType) {
    this.connectionType = connectionType;
  }


  public AnalyzeIp200Response hostReverse(@javax.annotation.Nonnull String hostReverse) {
    this.hostReverse = hostReverse;
    return this;
  }

  /**
   * Real time reverse DNS lookup result for the IP address.
   * @return hostReverse
   */
  @javax.annotation.Nonnull
  public String getHostReverse() {
    return hostReverse;
  }

  public void setHostReverse(@javax.annotation.Nonnull String hostReverse) {
    this.hostReverse = hostReverse;
  }


  public AnalyzeIp200Response geo(@javax.annotation.Nonnull Geo geo) {
    this.geo = geo;
    return this;
  }

  /**
   * Get geo
   * @return geo
   */
  @javax.annotation.Nonnull
  public Geo getGeo() {
    return geo;
  }

  public void setGeo(@javax.annotation.Nonnull Geo geo) {
    this.geo = geo;
  }


  public AnalyzeIp200Response whois(@javax.annotation.Nonnull Whois whois) {
    this.whois = whois;
    return this;
  }

  /**
   * Get whois
   * @return whois
   */
  @javax.annotation.Nonnull
  public Whois getWhois() {
    return whois;
  }

  public void setWhois(@javax.annotation.Nonnull Whois whois) {
    this.whois = whois;
  }


  public AnalyzeIp200Response trustedProvider(@javax.annotation.Nonnull TrustedProvider trustedProvider) {
    this.trustedProvider = trustedProvider;
    return this;
  }

  /**
   * Get trustedProvider
   * @return trustedProvider
   */
  @javax.annotation.Nonnull
  public TrustedProvider getTrustedProvider() {
    return trustedProvider;
  }

  public void setTrustedProvider(@javax.annotation.Nonnull TrustedProvider trustedProvider) {
    this.trustedProvider = trustedProvider;
  }


  public AnalyzeIp200Response blocklisted(@javax.annotation.Nonnull BlockListed blocklisted) {
    this.blocklisted = blocklisted;
    return this;
  }

  /**
   * Get blocklisted
   * @return blocklisted
   */
  @javax.annotation.Nonnull
  public BlockListed getBlocklisted() {
    return blocklisted;
  }

  public void setBlocklisted(@javax.annotation.Nonnull BlockListed blocklisted) {
    this.blocklisted = blocklisted;
  }


  public AnalyzeIp200Response riskReport(@javax.annotation.Nonnull RiskReport riskReport) {
    this.riskReport = riskReport;
    return this;
  }

  /**
   * Get riskReport
   * @return riskReport
   */
  @javax.annotation.Nonnull
  public RiskReport getRiskReport() {
    return riskReport;
  }

  public void setRiskReport(@javax.annotation.Nonnull RiskReport riskReport) {
    this.riskReport = riskReport;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AnalyzeIp200Response analyzeIp200Response = (AnalyzeIp200Response) o;
    return Objects.equals(this.ipAddress, analyzeIp200Response.ipAddress) &&
        Objects.equals(this.ipAddressNumber, analyzeIp200Response.ipAddressNumber) &&
        Objects.equals(this.ipType, analyzeIp200Response.ipType) &&
        Objects.equals(this.ipCidr, analyzeIp200Response.ipCidr) &&
        Objects.equals(this.connectionType, analyzeIp200Response.connectionType) &&
        Objects.equals(this.hostReverse, analyzeIp200Response.hostReverse) &&
        Objects.equals(this.geo, analyzeIp200Response.geo) &&
        Objects.equals(this.whois, analyzeIp200Response.whois) &&
        Objects.equals(this.trustedProvider, analyzeIp200Response.trustedProvider) &&
        Objects.equals(this.blocklisted, analyzeIp200Response.blocklisted) &&
        Objects.equals(this.riskReport, analyzeIp200Response.riskReport);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ipAddress, ipAddressNumber, ipType, ipCidr, connectionType, hostReverse, geo, whois, trustedProvider, blocklisted, riskReport);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AnalyzeIp200Response {\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    ipAddressNumber: ").append(toIndentedString(ipAddressNumber)).append("\n");
    sb.append("    ipType: ").append(toIndentedString(ipType)).append("\n");
    sb.append("    ipCidr: ").append(toIndentedString(ipCidr)).append("\n");
    sb.append("    connectionType: ").append(toIndentedString(connectionType)).append("\n");
    sb.append("    hostReverse: ").append(toIndentedString(hostReverse)).append("\n");
    sb.append("    geo: ").append(toIndentedString(geo)).append("\n");
    sb.append("    whois: ").append(toIndentedString(whois)).append("\n");
    sb.append("    trustedProvider: ").append(toIndentedString(trustedProvider)).append("\n");
    sb.append("    blocklisted: ").append(toIndentedString(blocklisted)).append("\n");
    sb.append("    riskReport: ").append(toIndentedString(riskReport)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ipAddress");
    openapiFields.add("ipAddressNumber");
    openapiFields.add("ipType");
    openapiFields.add("ipCidr");
    openapiFields.add("connectionType");
    openapiFields.add("hostReverse");
    openapiFields.add("geo");
    openapiFields.add("whois");
    openapiFields.add("trustedProvider");
    openapiFields.add("blocklisted");
    openapiFields.add("riskReport");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ipAddress");
    openapiRequiredFields.add("ipAddressNumber");
    openapiRequiredFields.add("ipType");
    openapiRequiredFields.add("ipCidr");
    openapiRequiredFields.add("connectionType");
    openapiRequiredFields.add("hostReverse");
    openapiRequiredFields.add("geo");
    openapiRequiredFields.add("whois");
    openapiRequiredFields.add("trustedProvider");
    openapiRequiredFields.add("blocklisted");
    openapiRequiredFields.add("riskReport");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AnalyzeIp200Response
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AnalyzeIp200Response.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AnalyzeIp200Response is not found in the empty JSON string", AnalyzeIp200Response.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AnalyzeIp200Response.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AnalyzeIp200Response` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AnalyzeIp200Response.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("ipAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipAddress").toString()));
      }
      if (!jsonObj.get("ipType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipType").toString()));
      }
      if (!jsonObj.get("ipCidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipCidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipCidr").toString()));
      }
      if (!jsonObj.get("connectionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `connectionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("connectionType").toString()));
      }
      if (!jsonObj.get("hostReverse").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostReverse` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostReverse").toString()));
      }
      // validate the required field `geo`
      Geo.validateJsonElement(jsonObj.get("geo"));
      // validate the required field `whois`
      Whois.validateJsonElement(jsonObj.get("whois"));
      // validate the required field `trustedProvider`
      TrustedProvider.validateJsonElement(jsonObj.get("trustedProvider"));
      // validate the required field `blocklisted`
      BlockListed.validateJsonElement(jsonObj.get("blocklisted"));
      // validate the required field `riskReport`
      RiskReport.validateJsonElement(jsonObj.get("riskReport"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AnalyzeIp200Response.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AnalyzeIp200Response' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AnalyzeIp200Response> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AnalyzeIp200Response.class));

       return (TypeAdapter<T>) new TypeAdapter<AnalyzeIp200Response>() {
           @Override
           public void write(JsonWriter out, AnalyzeIp200Response value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AnalyzeIp200Response read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AnalyzeIp200Response given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AnalyzeIp200Response
   * @throws IOException if the JSON string is invalid with respect to AnalyzeIp200Response
   */
  public static AnalyzeIp200Response fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnalyzeIp200Response.class);
  }

  /**
   * Convert an instance of AnalyzeIp200Response to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

