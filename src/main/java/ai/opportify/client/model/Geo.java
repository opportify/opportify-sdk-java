/*
 * Opportify Insights API
 * ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, corporate or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://www.opportify.ai).
 * https://www.opportify.ai
 * Do not edit the class manually.
 */


package ai.opportify.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ai.opportify.client.JSON;

/**
 * ### Geolocation Determination &amp; Confidence Levels Geolocation details are derived by analyzing the provided IP address using data aggregated from a wide range of sources, both official and unofficial (such as user-generated data, open-source, or crowdsourced). This data is meticulously evaluated and ranked using a proprietary weighted reliability score that is tailored to the specific characteristics and trustworthiness of each data source.  ---  #### Confidence Levels  The geolocation process assigns a confidence level to each level of granularity. These levels reflect the probability of accuracy based on the reliability of the data and analysis:  - **Continent-Level (99%)**: The determination of the continent is highly reliable, with a near-certain accuracy rate of 99%. - **Country-Level (98%)**: Locating the specific country has a very high accuracy of 98%, reflecting reliable cross-verification. - **Region-Level (70–90%)**: Identifying regions (such as states or provinces) has moderate to high accuracy, depending on the data quality and density for the given area. - **City-Level (50–70%)**: Pinpointing the specific city is moderately accurate, influenced by factors such as ISP data resolution and urban vs. rural settings. - **Specific Area/Point (5–40%)**: Pinpointing a highly specific area (e.g., a neighborhood or street) has a significantly lower confidence level due to inherent limitations in IP-based geolocation technology.  ---  #### Key Features  - **Alphabetical Object Sorting**:     The keys in the returned geolocation object are consistently sorted alphabetically, ensuring a predictable structure for easier integration and parsing.  ---  ### Response Elements 
 */
@javax.annotation.Generated(value = "ai.opportify.codegen.languages.JavaClientCodegen", date = "2025-01-07T17:36:50.096636-08:00[America/Los_Angeles]", comments = "Generator version: 7.10.0")
public class Geo {
  public static final String SERIALIZED_NAME_CONTINENT = "continent";
  @SerializedName(SERIALIZED_NAME_CONTINENT)
  @javax.annotation.Nullable
  private String continent;

  public static final String SERIALIZED_NAME_COUNTRY_CODE = "countryCode";
  @SerializedName(SERIALIZED_NAME_COUNTRY_CODE)
  @javax.annotation.Nullable
  private String countryCode;

  public static final String SERIALIZED_NAME_COUNTRY_NAME = "countryName";
  @SerializedName(SERIALIZED_NAME_COUNTRY_NAME)
  @javax.annotation.Nullable
  private String countryName;

  public static final String SERIALIZED_NAME_COUNTRY_SHORT_NAME = "countryShortName";
  @SerializedName(SERIALIZED_NAME_COUNTRY_SHORT_NAME)
  @javax.annotation.Nullable
  private String countryShortName;

  public static final String SERIALIZED_NAME_CITY = "city";
  @SerializedName(SERIALIZED_NAME_CITY)
  @javax.annotation.Nullable
  private String city;

  public static final String SERIALIZED_NAME_CURRENCY_CODE = "currencyCode";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CODE)
  @javax.annotation.Nullable
  private String currencyCode;

  public static final String SERIALIZED_NAME_DOMAIN_EXTENSION = "domainExtension";
  @SerializedName(SERIALIZED_NAME_DOMAIN_EXTENSION)
  @javax.annotation.Nullable
  private String domainExtension;

  public static final String SERIALIZED_NAME_LANGUAGES = "languages";
  @SerializedName(SERIALIZED_NAME_LANGUAGES)
  @javax.annotation.Nullable
  private String languages;

  public static final String SERIALIZED_NAME_LATITUDE = "latitude";
  @SerializedName(SERIALIZED_NAME_LATITUDE)
  @javax.annotation.Nullable
  private BigDecimal latitude;

  public static final String SERIALIZED_NAME_LONGITUDE = "longitude";
  @SerializedName(SERIALIZED_NAME_LONGITUDE)
  @javax.annotation.Nullable
  private BigDecimal longitude;

  public static final String SERIALIZED_NAME_POSTAL_CODE = "postalCode";
  @SerializedName(SERIALIZED_NAME_POSTAL_CODE)
  @javax.annotation.Nullable
  private String postalCode;

  public static final String SERIALIZED_NAME_PHONE_INT_CODE = "phoneIntCode";
  @SerializedName(SERIALIZED_NAME_PHONE_INT_CODE)
  @javax.annotation.Nullable
  private String phoneIntCode;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  @javax.annotation.Nullable
  private String region;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  @javax.annotation.Nullable
  private String timezone;

  public Geo() {
  }

  public Geo continent(@javax.annotation.Nullable String continent) {
    this.continent = continent;
    return this;
  }

  /**
   * Name of the continent. Normalized as \&quot;Title Case\&quot;.
   * @return continent
   */
  @javax.annotation.Nullable
  public String getContinent() {
    return continent;
  }

  public void setContinent(@javax.annotation.Nullable String continent) {
    this.continent = continent;
  }


  public Geo countryCode(@javax.annotation.Nullable String countryCode) {
    this.countryCode = countryCode;
    return this;
  }

  /**
   * ISO 3166-1 alpha-2 country code.
   * @return countryCode
   */
  @javax.annotation.Nullable
  public String getCountryCode() {
    return countryCode;
  }

  public void setCountryCode(@javax.annotation.Nullable String countryCode) {
    this.countryCode = countryCode;
  }


  public Geo countryName(@javax.annotation.Nullable String countryName) {
    this.countryName = countryName;
    return this;
  }

  /**
   * Full name of the country. Normalized as \&quot;Title Case\&quot;.
   * @return countryName
   */
  @javax.annotation.Nullable
  public String getCountryName() {
    return countryName;
  }

  public void setCountryName(@javax.annotation.Nullable String countryName) {
    this.countryName = countryName;
  }


  public Geo countryShortName(@javax.annotation.Nullable String countryShortName) {
    this.countryShortName = countryShortName;
    return this;
  }

  /**
   * ISO 3166-1 English short version. Normalized as \&quot;Title Case\&quot;.
   * @return countryShortName
   */
  @javax.annotation.Nullable
  public String getCountryShortName() {
    return countryShortName;
  }

  public void setCountryShortName(@javax.annotation.Nullable String countryShortName) {
    this.countryShortName = countryShortName;
  }


  public Geo city(@javax.annotation.Nullable String city) {
    this.city = city;
    return this;
  }

  /**
   * Name of the city. Normalized as \&quot;Title Case\&quot;.
   * @return city
   */
  @javax.annotation.Nullable
  public String getCity() {
    return city;
  }

  public void setCity(@javax.annotation.Nullable String city) {
    this.city = city;
  }


  public Geo currencyCode(@javax.annotation.Nullable String currencyCode) {
    this.currencyCode = currencyCode;
    return this;
  }

  /**
   * ISO 4217 currency code.
   * @return currencyCode
   */
  @javax.annotation.Nullable
  public String getCurrencyCode() {
    return currencyCode;
  }

  public void setCurrencyCode(@javax.annotation.Nullable String currencyCode) {
    this.currencyCode = currencyCode;
  }


  public Geo domainExtension(@javax.annotation.Nullable String domainExtension) {
    this.domainExtension = domainExtension;
    return this;
  }

  /**
   * Top-level domain (TLD) for the country. 63 characters limit. IANA / ICANN defined.
   * @return domainExtension
   */
  @javax.annotation.Nullable
  public String getDomainExtension() {
    return domainExtension;
  }

  public void setDomainExtension(@javax.annotation.Nullable String domainExtension) {
    this.domainExtension = domainExtension;
  }


  public Geo languages(@javax.annotation.Nullable String languages) {
    this.languages = languages;
    return this;
  }

  /**
   * List of languages spoken in the country separated by commas. (BCP 47 (Best Current Practice 47))
   * @return languages
   */
  @javax.annotation.Nullable
  public String getLanguages() {
    return languages;
  }

  public void setLanguages(@javax.annotation.Nullable String languages) {
    this.languages = languages;
  }


  public Geo latitude(@javax.annotation.Nullable BigDecimal latitude) {
    this.latitude = latitude;
    return this;
  }

  /**
   * Latitude coordinate.
   * @return latitude
   */
  @javax.annotation.Nullable
  public BigDecimal getLatitude() {
    return latitude;
  }

  public void setLatitude(@javax.annotation.Nullable BigDecimal latitude) {
    this.latitude = latitude;
  }


  public Geo longitude(@javax.annotation.Nullable BigDecimal longitude) {
    this.longitude = longitude;
    return this;
  }

  /**
   * Longitude coordinate.
   * @return longitude
   */
  @javax.annotation.Nullable
  public BigDecimal getLongitude() {
    return longitude;
  }

  public void setLongitude(@javax.annotation.Nullable BigDecimal longitude) {
    this.longitude = longitude;
  }


  public Geo postalCode(@javax.annotation.Nullable String postalCode) {
    this.postalCode = postalCode;
    return this;
  }

  /**
   * Postal code. Normalized to all capital letters when applicable.
   * @return postalCode
   */
  @javax.annotation.Nullable
  public String getPostalCode() {
    return postalCode;
  }

  public void setPostalCode(@javax.annotation.Nullable String postalCode) {
    this.postalCode = postalCode;
  }


  public Geo phoneIntCode(@javax.annotation.Nullable String phoneIntCode) {
    this.phoneIntCode = phoneIntCode;
    return this;
  }

  /**
   * International dialing code.
   * @return phoneIntCode
   */
  @javax.annotation.Nullable
  public String getPhoneIntCode() {
    return phoneIntCode;
  }

  public void setPhoneIntCode(@javax.annotation.Nullable String phoneIntCode) {
    this.phoneIntCode = phoneIntCode;
  }


  public Geo region(@javax.annotation.Nullable String region) {
    this.region = region;
    return this;
  }

  /**
   * Name of the region, province, or state. Normalized as \&quot;Title Case\&quot;.
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(@javax.annotation.Nullable String region) {
    this.region = region;
  }


  public Geo timezone(@javax.annotation.Nullable String timezone) {
    this.timezone = timezone;
    return this;
  }

  /**
   * Timezone in IANA format.
   * @return timezone
   */
  @javax.annotation.Nullable
  public String getTimezone() {
    return timezone;
  }

  public void setTimezone(@javax.annotation.Nullable String timezone) {
    this.timezone = timezone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Geo geo = (Geo) o;
    return Objects.equals(this.continent, geo.continent) &&
        Objects.equals(this.countryCode, geo.countryCode) &&
        Objects.equals(this.countryName, geo.countryName) &&
        Objects.equals(this.countryShortName, geo.countryShortName) &&
        Objects.equals(this.city, geo.city) &&
        Objects.equals(this.currencyCode, geo.currencyCode) &&
        Objects.equals(this.domainExtension, geo.domainExtension) &&
        Objects.equals(this.languages, geo.languages) &&
        Objects.equals(this.latitude, geo.latitude) &&
        Objects.equals(this.longitude, geo.longitude) &&
        Objects.equals(this.postalCode, geo.postalCode) &&
        Objects.equals(this.phoneIntCode, geo.phoneIntCode) &&
        Objects.equals(this.region, geo.region) &&
        Objects.equals(this.timezone, geo.timezone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(continent, countryCode, countryName, countryShortName, city, currencyCode, domainExtension, languages, latitude, longitude, postalCode, phoneIntCode, region, timezone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Geo {\n");
    sb.append("    continent: ").append(toIndentedString(continent)).append("\n");
    sb.append("    countryCode: ").append(toIndentedString(countryCode)).append("\n");
    sb.append("    countryName: ").append(toIndentedString(countryName)).append("\n");
    sb.append("    countryShortName: ").append(toIndentedString(countryShortName)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    currencyCode: ").append(toIndentedString(currencyCode)).append("\n");
    sb.append("    domainExtension: ").append(toIndentedString(domainExtension)).append("\n");
    sb.append("    languages: ").append(toIndentedString(languages)).append("\n");
    sb.append("    latitude: ").append(toIndentedString(latitude)).append("\n");
    sb.append("    longitude: ").append(toIndentedString(longitude)).append("\n");
    sb.append("    postalCode: ").append(toIndentedString(postalCode)).append("\n");
    sb.append("    phoneIntCode: ").append(toIndentedString(phoneIntCode)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("continent");
    openapiFields.add("countryCode");
    openapiFields.add("countryName");
    openapiFields.add("countryShortName");
    openapiFields.add("city");
    openapiFields.add("currencyCode");
    openapiFields.add("domainExtension");
    openapiFields.add("languages");
    openapiFields.add("latitude");
    openapiFields.add("longitude");
    openapiFields.add("postalCode");
    openapiFields.add("phoneIntCode");
    openapiFields.add("region");
    openapiFields.add("timezone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Geo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Geo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Geo is not found in the empty JSON string", Geo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Geo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Geo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("continent") != null && !jsonObj.get("continent").isJsonNull()) && !jsonObj.get("continent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `continent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("continent").toString()));
      }
      if ((jsonObj.get("countryCode") != null && !jsonObj.get("countryCode").isJsonNull()) && !jsonObj.get("countryCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryCode").toString()));
      }
      if ((jsonObj.get("countryName") != null && !jsonObj.get("countryName").isJsonNull()) && !jsonObj.get("countryName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryName").toString()));
      }
      if ((jsonObj.get("countryShortName") != null && !jsonObj.get("countryShortName").isJsonNull()) && !jsonObj.get("countryShortName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryShortName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryShortName").toString()));
      }
      if ((jsonObj.get("city") != null && !jsonObj.get("city").isJsonNull()) && !jsonObj.get("city").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `city` to be a primitive type in the JSON string but got `%s`", jsonObj.get("city").toString()));
      }
      if ((jsonObj.get("currencyCode") != null && !jsonObj.get("currencyCode").isJsonNull()) && !jsonObj.get("currencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currencyCode").toString()));
      }
      if ((jsonObj.get("domainExtension") != null && !jsonObj.get("domainExtension").isJsonNull()) && !jsonObj.get("domainExtension").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `domainExtension` to be a primitive type in the JSON string but got `%s`", jsonObj.get("domainExtension").toString()));
      }
      if ((jsonObj.get("languages") != null && !jsonObj.get("languages").isJsonNull()) && !jsonObj.get("languages").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `languages` to be a primitive type in the JSON string but got `%s`", jsonObj.get("languages").toString()));
      }
      if ((jsonObj.get("postalCode") != null && !jsonObj.get("postalCode").isJsonNull()) && !jsonObj.get("postalCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postalCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postalCode").toString()));
      }
      if ((jsonObj.get("phoneIntCode") != null && !jsonObj.get("phoneIntCode").isJsonNull()) && !jsonObj.get("phoneIntCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `phoneIntCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("phoneIntCode").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
      if ((jsonObj.get("timezone") != null && !jsonObj.get("timezone").isJsonNull()) && !jsonObj.get("timezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Geo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Geo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Geo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Geo.class));

       return (TypeAdapter<T>) new TypeAdapter<Geo>() {
           @Override
           public void write(JsonWriter out, Geo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Geo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Geo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Geo
   * @throws IOException if the JSON string is invalid with respect to Geo
   */
  public static Geo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Geo.class);
  }

  /**
   * Convert an instance of Geo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

