/*
 * Opportify Insights API
 * ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, private or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://www.opportify.ai).
 * https://www.opportify.ai
 * Do not edit the class manually.
 */


package ai.opportify.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ai.opportify.client.JSON;

/**
 * Summary of the domain-level enrichment returned when enrichment is available and not opted out via &#x60;enableDomainEnrichment&#x60;.  The &#x60;ageYears&#x60; value is sourced from stored enrichment data to keep responses deterministic across subsequent calls. 
 */
@javax.annotation.Generated(value = "ai.opportify.codegen.languages.JavaClientCodegen", date = "2025-11-08T12:20:24.871327-08:00[America/Los_Angeles]", comments = "Generator version: 7.12.0")
public class EmailDomain {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name = "";

  public static final String SERIALIZED_NAME_ENRICHMENT_AVAILABLE = "enrichmentAvailable";
  @SerializedName(SERIALIZED_NAME_ENRICHMENT_AVAILABLE)
  @javax.annotation.Nonnull
  private Boolean enrichmentAvailable = false;

  public static final String SERIALIZED_NAME_CREATION_DATE = "creationDate";
  @SerializedName(SERIALIZED_NAME_CREATION_DATE)
  @javax.annotation.Nonnull
  private OffsetDateTime creationDate;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "expirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  @javax.annotation.Nonnull
  private OffsetDateTime expirationDate;

  public static final String SERIALIZED_NAME_UPDATED_DATE = "updatedDate";
  @SerializedName(SERIALIZED_NAME_UPDATED_DATE)
  @javax.annotation.Nonnull
  private OffsetDateTime updatedDate;

  public static final String SERIALIZED_NAME_AGE_YEARS = "ageYears";
  @SerializedName(SERIALIZED_NAME_AGE_YEARS)
  @javax.annotation.Nonnull
  private Integer ageYears = 0;

  public static final String SERIALIZED_NAME_REGISTRAR = "registrar";
  @SerializedName(SERIALIZED_NAME_REGISTRAR)
  @javax.annotation.Nonnull
  private String registrar = "";

  public static final String SERIALIZED_NAME_IS_BLOCK_LISTED = "isBlockListed";
  @SerializedName(SERIALIZED_NAME_IS_BLOCK_LISTED)
  @javax.annotation.Nonnull
  private Boolean isBlockListed = false;

  /**
   * Status of the domain&#39;s MTA-STS configuration.
   */
  @JsonAdapter(MtaStsStatusEnum.Adapter.class)
  public enum MtaStsStatusEnum {
    PRESENT("present"),
    
    INVALID("invalid"),
    
    ABSENT("absent"),
    
    UNKNOWN("unknown");

    private String value;

    MtaStsStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MtaStsStatusEnum fromValue(String value) {
      for (MtaStsStatusEnum b : MtaStsStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MtaStsStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MtaStsStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MtaStsStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MtaStsStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MtaStsStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MTA_STS_STATUS = "mtaStsStatus";
  @SerializedName(SERIALIZED_NAME_MTA_STS_STATUS)
  @javax.annotation.Nonnull
  private MtaStsStatusEnum mtaStsStatus = MtaStsStatusEnum.UNKNOWN;

  /**
   * BIMI (Brand Indicators for Message Identification) status.
   */
  @JsonAdapter(BimiStatusEnum.Adapter.class)
  public enum BimiStatusEnum {
    PRESENT("present"),
    
    PRESENT_NO_VMC("present-no-vmc"),
    
    INVALID("invalid"),
    
    ABSENT("absent"),
    
    UNKNOWN("unknown");

    private String value;

    BimiStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BimiStatusEnum fromValue(String value) {
      for (BimiStatusEnum b : BimiStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BimiStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BimiStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BimiStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BimiStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BimiStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BIMI_STATUS = "bimiStatus";
  @SerializedName(SERIALIZED_NAME_BIMI_STATUS)
  @javax.annotation.Nonnull
  private BimiStatusEnum bimiStatus = BimiStatusEnum.UNKNOWN;

  public static final String SERIALIZED_NAME_HAS_V_M_C = "hasVMC";
  @SerializedName(SERIALIZED_NAME_HAS_V_M_C)
  @javax.annotation.Nonnull
  private Boolean hasVMC = false;

  public static final String SERIALIZED_NAME_A_RECORD_VALID = "aRecordValid";
  @SerializedName(SERIALIZED_NAME_A_RECORD_VALID)
  @javax.annotation.Nonnull
  private Boolean aRecordValid = false;

  public static final String SERIALIZED_NAME_A_RECORD_REVERSE_HOST = "aRecordReverseHost";
  @SerializedName(SERIALIZED_NAME_A_RECORD_REVERSE_HOST)
  @javax.annotation.Nonnull
  private String aRecordReverseHost = "";

  public static final String SERIALIZED_NAME_SSL_VALID = "sslValid";
  @SerializedName(SERIALIZED_NAME_SSL_VALID)
  @javax.annotation.Nonnull
  private Boolean sslValid = false;

  public EmailDomain() {
  }

  public EmailDomain name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * Fully qualified domain name associated with the email.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public EmailDomain enrichmentAvailable(@javax.annotation.Nonnull Boolean enrichmentAvailable) {
    this.enrichmentAvailable = enrichmentAvailable;
    return this;
  }

  /**
   * Indicates whether enrichment data was available at analysis time.  When this is &#x60;false&#x60;, all enrichment fields (except &#x60;name&#x60;) represent safe defaults and must not be used for decision-making. Only the &#x60;name&#x60; field (the queried domain) and the default values of boolean and enum fields are meaningful; all other fields should be treated as informational only and ignored for any logic or risk assessment. 
   * @return enrichmentAvailable
   */
  @javax.annotation.Nonnull
  public Boolean getEnrichmentAvailable() {
    return enrichmentAvailable;
  }

  public void setEnrichmentAvailable(@javax.annotation.Nonnull Boolean enrichmentAvailable) {
    this.enrichmentAvailable = enrichmentAvailable;
  }


  public EmailDomain creationDate(@javax.annotation.Nonnull OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * Domain creation timestamp (ISO 8601). Returns an empty string when enrichment data is unavailable.
   * @return creationDate
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(@javax.annotation.Nonnull OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }


  public EmailDomain expirationDate(@javax.annotation.Nonnull OffsetDateTime expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

  /**
   * Domain expiration timestamp (ISO 8601). Returns an empty string when enrichment data is unavailable.
   * @return expirationDate
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(@javax.annotation.Nonnull OffsetDateTime expirationDate) {
    this.expirationDate = expirationDate;
  }


  public EmailDomain updatedDate(@javax.annotation.Nonnull OffsetDateTime updatedDate) {
    this.updatedDate = updatedDate;
    return this;
  }

  /**
   * Last WHOIS update timestamp (ISO 8601). Returns an empty string when enrichment data is unavailable.
   * @return updatedDate
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getUpdatedDate() {
    return updatedDate;
  }

  public void setUpdatedDate(@javax.annotation.Nonnull OffsetDateTime updatedDate) {
    this.updatedDate = updatedDate;
  }


  public EmailDomain ageYears(@javax.annotation.Nonnull Integer ageYears) {
    this.ageYears = ageYears;
    return this;
  }

  /**
   * Domain age in whole years based on stored enrichment data. Returns 0 for domains younger than one year.
   * @return ageYears
   */
  @javax.annotation.Nonnull
  public Integer getAgeYears() {
    return ageYears;
  }

  public void setAgeYears(@javax.annotation.Nonnull Integer ageYears) {
    this.ageYears = ageYears;
  }


  public EmailDomain registrar(@javax.annotation.Nonnull String registrar) {
    this.registrar = registrar;
    return this;
  }

  /**
   * Registrar recorded for the domain.
   * @return registrar
   */
  @javax.annotation.Nonnull
  public String getRegistrar() {
    return registrar;
  }

  public void setRegistrar(@javax.annotation.Nonnull String registrar) {
    this.registrar = registrar;
  }


  public EmailDomain isBlockListed(@javax.annotation.Nonnull Boolean isBlockListed) {
    this.isBlockListed = isBlockListed;
    return this;
  }

  /**
   * Indicates whether the domain appears in monitored blocklists.
   * @return isBlockListed
   */
  @javax.annotation.Nonnull
  public Boolean getIsBlockListed() {
    return isBlockListed;
  }

  public void setIsBlockListed(@javax.annotation.Nonnull Boolean isBlockListed) {
    this.isBlockListed = isBlockListed;
  }


  public EmailDomain mtaStsStatus(@javax.annotation.Nonnull MtaStsStatusEnum mtaStsStatus) {
    this.mtaStsStatus = mtaStsStatus;
    return this;
  }

  /**
   * Status of the domain&#39;s MTA-STS configuration.
   * @return mtaStsStatus
   */
  @javax.annotation.Nonnull
  public MtaStsStatusEnum getMtaStsStatus() {
    return mtaStsStatus;
  }

  public void setMtaStsStatus(@javax.annotation.Nonnull MtaStsStatusEnum mtaStsStatus) {
    this.mtaStsStatus = mtaStsStatus;
  }


  public EmailDomain bimiStatus(@javax.annotation.Nonnull BimiStatusEnum bimiStatus) {
    this.bimiStatus = bimiStatus;
    return this;
  }

  /**
   * BIMI (Brand Indicators for Message Identification) status.
   * @return bimiStatus
   */
  @javax.annotation.Nonnull
  public BimiStatusEnum getBimiStatus() {
    return bimiStatus;
  }

  public void setBimiStatus(@javax.annotation.Nonnull BimiStatusEnum bimiStatus) {
    this.bimiStatus = bimiStatus;
  }


  public EmailDomain hasVMC(@javax.annotation.Nonnull Boolean hasVMC) {
    this.hasVMC = hasVMC;
    return this;
  }

  /**
   * Indicates whether a Verified Mark Certificate is associated with the domain.
   * @return hasVMC
   */
  @javax.annotation.Nonnull
  public Boolean getHasVMC() {
    return hasVMC;
  }

  public void setHasVMC(@javax.annotation.Nonnull Boolean hasVMC) {
    this.hasVMC = hasVMC;
  }


  public EmailDomain aRecordValid(@javax.annotation.Nonnull Boolean aRecordValid) {
    this.aRecordValid = aRecordValid;
    return this;
  }

  /**
   * Indicates whether the domain has valid A records.
   * @return aRecordValid
   */
  @javax.annotation.Nonnull
  public Boolean getaRecordValid() {
    return aRecordValid;
  }

  public void setaRecordValid(@javax.annotation.Nonnull Boolean aRecordValid) {
    this.aRecordValid = aRecordValid;
  }


  public EmailDomain aRecordReverseHost(@javax.annotation.Nonnull String aRecordReverseHost) {
    this.aRecordReverseHost = aRecordReverseHost;
    return this;
  }

  /**
   * Reverse hostname observed for the A record when available. Empty string when no reverse mapping is returned.
   * @return aRecordReverseHost
   */
  @javax.annotation.Nonnull
  public String getaRecordReverseHost() {
    return aRecordReverseHost;
  }

  public void setaRecordReverseHost(@javax.annotation.Nonnull String aRecordReverseHost) {
    this.aRecordReverseHost = aRecordReverseHost;
  }


  public EmailDomain sslValid(@javax.annotation.Nonnull Boolean sslValid) {
    this.sslValid = sslValid;
    return this;
  }

  /**
   * Indicates whether the domain serves a valid SSL certificate on common endpoints.
   * @return sslValid
   */
  @javax.annotation.Nonnull
  public Boolean getSslValid() {
    return sslValid;
  }

  public void setSslValid(@javax.annotation.Nonnull Boolean sslValid) {
    this.sslValid = sslValid;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EmailDomain emailDomain = (EmailDomain) o;
    return Objects.equals(this.name, emailDomain.name) &&
        Objects.equals(this.enrichmentAvailable, emailDomain.enrichmentAvailable) &&
        Objects.equals(this.creationDate, emailDomain.creationDate) &&
        Objects.equals(this.expirationDate, emailDomain.expirationDate) &&
        Objects.equals(this.updatedDate, emailDomain.updatedDate) &&
        Objects.equals(this.ageYears, emailDomain.ageYears) &&
        Objects.equals(this.registrar, emailDomain.registrar) &&
        Objects.equals(this.isBlockListed, emailDomain.isBlockListed) &&
        Objects.equals(this.mtaStsStatus, emailDomain.mtaStsStatus) &&
        Objects.equals(this.bimiStatus, emailDomain.bimiStatus) &&
        Objects.equals(this.hasVMC, emailDomain.hasVMC) &&
        Objects.equals(this.aRecordValid, emailDomain.aRecordValid) &&
        Objects.equals(this.aRecordReverseHost, emailDomain.aRecordReverseHost) &&
        Objects.equals(this.sslValid, emailDomain.sslValid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, enrichmentAvailable, creationDate, expirationDate, updatedDate, ageYears, registrar, isBlockListed, mtaStsStatus, bimiStatus, hasVMC, aRecordValid, aRecordReverseHost, sslValid);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EmailDomain {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    enrichmentAvailable: ").append(toIndentedString(enrichmentAvailable)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    updatedDate: ").append(toIndentedString(updatedDate)).append("\n");
    sb.append("    ageYears: ").append(toIndentedString(ageYears)).append("\n");
    sb.append("    registrar: ").append(toIndentedString(registrar)).append("\n");
    sb.append("    isBlockListed: ").append(toIndentedString(isBlockListed)).append("\n");
    sb.append("    mtaStsStatus: ").append(toIndentedString(mtaStsStatus)).append("\n");
    sb.append("    bimiStatus: ").append(toIndentedString(bimiStatus)).append("\n");
    sb.append("    hasVMC: ").append(toIndentedString(hasVMC)).append("\n");
    sb.append("    aRecordValid: ").append(toIndentedString(aRecordValid)).append("\n");
    sb.append("    aRecordReverseHost: ").append(toIndentedString(aRecordReverseHost)).append("\n");
    sb.append("    sslValid: ").append(toIndentedString(sslValid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("enrichmentAvailable");
    openapiFields.add("creationDate");
    openapiFields.add("expirationDate");
    openapiFields.add("updatedDate");
    openapiFields.add("ageYears");
    openapiFields.add("registrar");
    openapiFields.add("isBlockListed");
    openapiFields.add("mtaStsStatus");
    openapiFields.add("bimiStatus");
    openapiFields.add("hasVMC");
    openapiFields.add("aRecordValid");
    openapiFields.add("aRecordReverseHost");
    openapiFields.add("sslValid");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("enrichmentAvailable");
    openapiRequiredFields.add("creationDate");
    openapiRequiredFields.add("expirationDate");
    openapiRequiredFields.add("updatedDate");
    openapiRequiredFields.add("ageYears");
    openapiRequiredFields.add("registrar");
    openapiRequiredFields.add("isBlockListed");
    openapiRequiredFields.add("mtaStsStatus");
    openapiRequiredFields.add("bimiStatus");
    openapiRequiredFields.add("hasVMC");
    openapiRequiredFields.add("aRecordValid");
    openapiRequiredFields.add("aRecordReverseHost");
    openapiRequiredFields.add("sslValid");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EmailDomain
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EmailDomain.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EmailDomain is not found in the empty JSON string", EmailDomain.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EmailDomain.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EmailDomain` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : EmailDomain.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("registrar").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `registrar` to be a primitive type in the JSON string but got `%s`", jsonObj.get("registrar").toString()));
      }
      if (!jsonObj.get("mtaStsStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mtaStsStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mtaStsStatus").toString()));
      }
      // validate the required field `mtaStsStatus`
      MtaStsStatusEnum.validateJsonElement(jsonObj.get("mtaStsStatus"));
      if (!jsonObj.get("bimiStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bimiStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bimiStatus").toString()));
      }
      // validate the required field `bimiStatus`
      BimiStatusEnum.validateJsonElement(jsonObj.get("bimiStatus"));
      if (!jsonObj.get("aRecordReverseHost").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aRecordReverseHost` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aRecordReverseHost").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EmailDomain.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EmailDomain' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EmailDomain> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EmailDomain.class));

       return (TypeAdapter<T>) new TypeAdapter<EmailDomain>() {
           @Override
           public void write(JsonWriter out, EmailDomain value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EmailDomain read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EmailDomain given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EmailDomain
   * @throws IOException if the JSON string is invalid with respect to EmailDomain
   */
  public static EmailDomain fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EmailDomain.class);
  }

  /**
   * Convert an instance of EmailDomain to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

